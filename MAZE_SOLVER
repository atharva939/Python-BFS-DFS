import pygame
import collections  # Used for the queue in BFS

# --- Pygame Setup ---
# The dimensions of the visualization window
WINDOW_WIDTH = 1000
WINDOW_HEIGHT = 1000

# The number of rows and columns in the grid
GRID_ROWS = 50
GRID_COLS = 50

# The size of each square (node) in pixels
SQUARE_SIZE = WINDOW_WIDTH // GRID_COLS

# Define some colors for the nodes and visualization
WHITE = (255, 255, 255)  # Default color for an open node
BLACK = (0, 0, 0)  # Color for walls (obstacles)
ORANGE = (255, 165, 0)  # Color for the start node
TURQUOISE = (64, 224, 208)  # Color for the end node
GREEN = (0, 255, 0)  # Color for nodes visited in the search
RED = (255, 0, 0)  # Color for nodes in the open set (to be visited)
PURPLE = (128, 0, 128)  # Color for the final path

# Initialize Pygame
pygame.init()
pygame.display.set_caption("BFS and DFS Pathfinding Visualizer")
screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))


# --- Node Class ---
class Node:
    """Represents a single square (node) on the grid."""

    def __init__(self, row, col, size):
        self.row = row
        self.col = col
        self.x = col * size
        self.y = row * size
        self.color = WHITE
        self.size = size
        self.neighbors = []
        self.parent = None  

    def get_pos(self):
        return self.row, self.col

    def is_wall(self):
        return self.color == BLACK

    def is_start(self):
        return self.color == TURQUOISE

    def is_end(self):
        return self.color == ORANGE

    def reset(self):
        self.color = WHITE

    def make_start(self):
        self.color = TURQUOISE

    def make_end(self):
        self.color = ORANGE

    def make_wall(self):
        self.color = BLACK

    def make_path(self):
        self.color = PURPLE

    def make_open(self):
        self.color = GREEN

    def make_closed(self):
        self.color = RED

    def draw(self, win):
        pygame.draw.rect(win, self.color, (self.x, self.y, self.size, self.size))

    def update_neighbors(self, grid):
        """Finds valid neighbors (not walls) for the current node."""
        self.neighbors = []
        # Check directions: up, down, left, right
        if self.row > 0 and not grid[self.row - 1][self.col].is_wall():
            self.neighbors.append(grid[self.row - 1][self.col])  # UP
        if self.row < GRID_ROWS - 1 and not grid[self.row + 1][self.col].is_wall():
            self.neighbors.append(grid[self.row + 1][self.col])  # DOWN
        if self.col > 0 and not grid[self.row][self.col - 1].is_wall():
            self.neighbors.append(grid[self.row][self.col - 1])  # LEFT
        if self.col < GRID_COLS - 1 and not grid[self.row][self.col + 1].is_wall():
            self.neighbors.append(grid[self.row][self.col + 1])  # RIGHT


# --- Grid Functions ---
def make_grid():
    """Creates a 2D list of Node objects."""
    grid = []
    for i in range(GRID_ROWS):
        grid.append([])
        for j in range(GRID_COLS):
            node = Node(i, j, SQUARE_SIZE)
            grid[i].append(node)
    return grid


def draw_grid_lines(win):
    """Draws the grid lines on the screen."""
    for i in range(GRID_ROWS):
        pygame.draw.line(win, BLACK, (0, i * SQUARE_SIZE), (WINDOW_WIDTH, i * SQUARE_SIZE))
        for j in range(GRID_COLS):
            pygame.draw.line(win, BLACK, (j * SQUARE_SIZE, 0), (j * SQUARE_SIZE, WINDOW_HEIGHT))


def draw(win, grid):
    """Draws the nodes and grid lines on the screen."""
    win.fill(WHITE)
    for row in grid:
        for node in row:
            node.draw(win)
    draw_grid_lines(win)
    pygame.display.update()


def get_clicked_pos(pos):
    """Converts a mouse click position to a grid row and column."""
    x, y = pos
    row = y // SQUARE_SIZE
    col = x // SQUARE_SIZE
    return row, col


# --- Algorithm Implementations ---
def reconstruct_path(current, draw_func):
    """Draws the path from the end node back to the start node."""
    while current.parent:
        current = current.parent
        if not current.is_start():  # Don't recolor the start node
            current.make_path()
        draw_func()


def bfs(draw_func, grid, start, end):
    """Performs a Breadth-First Search to find the shortest path."""
    queue = collections.deque()
    queue.append(start)
    visited = {start}

    # Run the algorithm
    while queue:
        # Check for user quit event
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()

        current = queue.popleft()

        if current == end:
            reconstruct_path(current, draw_func)
            end.make_end()
            return True

        for neighbor in current.neighbors:
            if neighbor not in visited:
                visited.add(neighbor)
                neighbor.parent = current
                queue.append(neighbor)

                if neighbor != end:
                    neighbor.make_open()

        draw_func()

        if current != start:
            current.make_closed()

    return False


def dfs(draw_func, grid, start, end):
    """Performs a Depth-First Search to find a path."""
    stack = [start]
    visited = {start}

    # Run the algorithm
    while stack:
        # Check for user quit event
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()

        current = stack.pop()

        if current == end:
            reconstruct_path(current, draw_func)
            end.make_end()
            return True

        for neighbor in current.neighbors:
            if neighbor not in visited:
                visited.add(neighbor)
                neighbor.parent = current
                stack.append(neighbor)

                if neighbor != end:
                    neighbor.make_open()

        draw_func()

        if current != start:
            current.make_closed()

    return False


# --- Main Game Loop ---
def main():
    grid = make_grid()
    start_node = None
    end_node = None
    running = True

    while running:
        draw(screen, grid)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

            # Left mouse button to set start/end/walls
            if pygame.mouse.get_pressed()[0]:
                pos = pygame.mouse.get_pos()
                row, col = get_clicked_pos(pos)
                node = grid[row][col]

                if not start_node and node != end_node:
                    start_node = node
                    start_node.make_start()
                elif not end_node and node != start_node:
                    end_node = node
                    end_node.make_end()
                elif node != start_node and node != end_node:
                    node.make_wall()

            # Right mouse button to reset a node
            elif pygame.mouse.get_pressed()[2]:
                pos = pygame.mouse.get_pos()
                row, col = get_clicked_pos(pos)
                node = grid[row][col]
                node.reset()
                if node == start_node:
                    start_node = None
                elif node == end_node:
                    end_node = None

            # Keyboard events
            if event.type == pygame.KEYDOWN:
                # Press 'B' to run BFS
                if event.key == pygame.K_b and start_node and end_node:
                    for row in grid:
                        for node in row:
                            node.update_neighbors(grid)
                    bfs(lambda: draw(screen, grid), grid, start_node, end_node)

                # Press 'D' to run DFS
                if event.key == pygame.K_d and start_node and end_node:
                    for row in grid:
                        for node in row:
                            node.update_neighbors(grid)
                    dfs(lambda: draw(screen, grid), grid, start_node, end_node)

                # Press 'C' to clear the grid
                if event.key == pygame.K_c:
                    start_node = None
                    end_node = None
                    grid = make_grid()

    pygame.quit()


if __name__ == "__main__":
    main()
